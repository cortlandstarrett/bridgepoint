---

Copyright 2013 Mentor Graphics Corp.  All Rights Reserved.

---

# Title goes here
### xtUML Project Design Note




1. Abstract
-----------
 

2. History
----------
 
 

3. Document References
----------------------
[1] /Documentation/internal/technical/notes/dts0100629397/dts0100629397.ant
[2] https://github.com/xtuml/internal/blob/master/doc-internal/notes/dts0100629397/ 


4. Background
-------------
In this section, outline the important points relating to this issue/bug that
the reader would need to know in order to understand the rest of this
document.

5. Requirements
---------------
5.1. Models executing in BridgePoint shall communicate with other tools 
     through a BridgePoint SVX interface.  
5.2. Port marking shall be used to identify the modeled components that 
     shall participate in SVX communication.  
5.3. A model executing in BridgePoint and communicating with other 
     models through SVX shall not need to be aware of the 
       algorithms in the other models. 
5.4 The port marked as svx should have a kind of graphical represntation 
     that distiguieshes it from the regular port
    [tbd_7.2.2]
   
   
6. Analysis
-----------
This section is only required if there is no preceding analysis note. If present
it sets out a brief analysis of the problem to be resolved by this design note.

* Item 1
* Item 2
* Item 3

7. Design 
---------
7.1 To be able to use SVX APIs Add svx.jar to the bp core plugin dependencies 
    Then modify the the generate.xml to add the svx.jar dependency 
	
7.2 Add attribute to the metamodel class Port to mark it as svx
    To realize a communication that goes through a port during verifier
	while running verifier that attribute is checked if it is true then the 
	communication is being routed to get or set values using the SVX API
	that attribute is of type boolean and named isSVX and its 
	full name is Mark As SVX
7.2.2 Show a graphical represntation of the port marked as svx 
      along with an indication that the svx connections has been established 
      correctly during the verifier run 	  
	

7.3 Port configurations for the preferences of each project 
   Port preferences are accessed to be configured from the SVX project preferences  menu item
7.3.1 create an SVX project preference node that shows on the xtuml project when selected 
      from model explorer view 
7.3.2 modify create_core_plugin_class.arc to add the SVX preferences node to the core plugin
7.3.3 create SVX preferences page that is used to configure the ports marked as svx
      the page shows a drop down list containing only the only components that have 
	  one port marked as svx or more 
	  when a component is selected a table showing all the ports marked as svx on the selected component
	  when a port on that table is selected a check is shown next to the port name and all the configurations
	  for that port become editable and a secondary table shows all the interface operations along with their  	  
	  corresponding configurable SVX signal names
7.3.3.1 port configuration table : 
        Port Name : not editable
		Channel Name :  at the first run will be initialized with the port name and when edited will be populated with
                 		the provided values
		Port Number   :  there will be no default value the user has to enter an integer number for the port
		isAppSequencer :  represents the client that will run first for svx (the client with the value false runs first)
		                  and will have default initial value of false 
		iP         :    will be initialized with the local host IP "127.0.0.1"
		lookUpName :    will have initial value of ""
		seconds    :    won't have initial value
		value      :    won't have initial value, 
		BIGendTime :    won't have initial value
	The columns that won't be provided a default value is to force the user to enter the value that will make 
	the correct communication with the other svx clients running 
	else the user might be under the false impression that the default values might make his model up and running 
	correctly without being modified. 
	Hover text to show help on each column providing simple tip on each configurable value. 
    
7.3.4 create SVX preferences store that contains the mapping between ports and created channels for them 
      Initially the store contains three hashmaps         
7.3.4.1	the first maps the port to a created SVX channel corresponding to that port the svx channel class is 
	    explained below 
7.3.4.2 the second maps holds the initialization values for each channel weather they are true or false 
	    so as not to initialize a channel twice while running the verifier
7.3.4.3 the third map maps the executable properties to it's corresponding signal name 

7.3.5 SVXChannel class represents the svx channel created holding its configuration values
      the values are populated from the table in the preferences window
      class SVXChannel {
	  String portName;
	  String channelName;
	  int portNumber;
	  boolean isAppSequencer;
	  String iP;
	  String lookUpName;
	  double seconds;
	  int value;
	  double BIGendTime;
       }
 
7.4 add External entity for communication between OAL and java SVX APIs 
    the implementation to that external entity is not generated it is
	coded in java that holds the communication with the svx APIs
	that external entity is named SVX it has two bridge operations:
7.4.1 the first bridge opration is named getSVXValue()
      this operation has a return type of real
	  this one is used to read the value provided for certain signal from the SVX bus 
	  it has two parameters of type UUID there parameters are messageValueId and portId
      there parameters are used to resolve the right svx channel and signal name 
	  configured for the value being read
7.4.2 The second bridge operation is named setSVXValue() this one is used to 
      send an svx value to the svx bus this one has three parameters of the type uuid 
	  these are valueId, portId and  invocationId they are used to resolve the right 
	  port and the value being sent to the port along with the configured signal name



7.7 SVX_C implementation code  

/com.mentor.nucleus.bp.core/src/com/mentor/nucleus/bp/core/Svx_c.java
Getsvxvalue(UUID, UUID)
retrieveId(UUID)
getSVXValue(Port_c, SVXChannel, UUID)
retrieveChannel(Port_c)
Setsvxvalue(UUID, UUID, UUID)
 Requirement_c  |->  from provider create a consumer
                |->  to provider create a generator  

				
Provision_c  	|->  from provider create a generator
                |->  to   provider create a consumer
			
			
			
7.5 Modify the operation getValue() of the class message value
    this operation when can't resolve the needed value returns a default value
    but an extra case is added to check if the port through wich this value is needed is marked as 
    svx port then the SVX::getSVXValue() bridge operation is called 
    and having the right uuid paramters sent to it 
    this operation gets the right sxv handles that resolves the value on the desired 
    svx channel and signal name 
    
    and then when the value is resolved using the java code imeplenentaion of that bridge 
    operation
	 then a return value instance is creatd that has a data type of type real related to it 
	 then the value that is resolved is set to that value
	 that's how the resolved values from svx is returned to the oal code format
 	

7.6  Modify the opratoin excute() in IntrfaceInvocation metamodel class 
     this opration is modified that when it's loose and not connected to other
	 port then when an operation is called across that port to send a value to svx 
     bus using the bridge operation SVX::getSVXValue() passing the right parameters 
     to that bridge operatin the value being sent to the svx is being resolved 
     along with it's originating port and signal name 
     that part is excuted in the java implenmentaion to that bridge operation 	 



8. Design Comments
------------------
 
     8.1    -Where is control transferred between verifier and SVX
         -How do we get data across the interface between verifier and SVX
         
         -When a message value is needed and the port is marked as SVX we do 
            
         -This synchronous
        
		-What about Events (asyncronous)?
          
  
   8.2 How does SVX look from in OAL?
         It is just a Port call.
         example: Port1::getCommandReading()
         
	8.3	 Does it block until time passes?
         No, it blocks until Svx_c.java::getSVXValue() returns
        -The amount of simulated time that passes during this
        is defined in the SVX properties.  
        -It does not interact with timers in verifiers according to Heba.  
		
		The time in the simulation has advanced.  Doesn't Verifiers
		time also have to advance?  They must be advanced at the same rate?
						-Dean suggests having another demo that focuses on this time-related
     
8.4   -BIGendTime - Campbell
    -What happens if there are different BIGendTime for different ports?
    -Use hover text to show help on each item - Bob
    -"value" is a bad name for a preference? 

9. Work Required
----------------
In this section, follow the same procedure outlined in the Work Required section
of the analysis note template.  Additional information can be added if it is
known at this time--for example, names of files to be worked on.

10. Unit Test
------------
Outline all the unit tests that need to pass and describe the method that you
will use to design and perform the tests.

End
---

