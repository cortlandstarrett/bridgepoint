---

Copyright 2013 Mentor Graphics Corp.  All Rights Reserved.

---

# Problems with Audit Realized Bindings
### xtUML Project Design Note


1. Abstract
-----------
A customer has reported issues with the "Audit Realized Bindings" feature.  This
note covers the analysis and proposed solutions for these issues.

2. Document References
----------------------
[1] Issues 44, https://github.com/xtuml/internal/issues/44  
[2] CQ DEI dts0100934989  

3. Background
-------------
A customer submitted a service request after encountering problems running 
"Audit Realized Bindings".  This feature is invoked via the context menu on 
either a package or a component.  The feature runs and creates a report that
details any problems linking hand-craft code pieces to components marked as 
realized in the model.

4. Requirements
---------------
4.1  Audit shall always display a report when it is finished running.  
4.2  Audit shall correctly report success when a valid jar file implements a 
  realized component.  
4.3  Audit shall correct report failure to bind when an invalid jar file is 
  specified for a realized component.  
  
5. Analysis
-----------
5.1  The SR and DEI actually encapsulate to different, but related issues with
  audit.  
5.2  The first issue is that when Audit is invoked on a component (via Model
  Explorer), the component itself is not part of the list of elements that are
  audited, only the children of the component are audited.  This is the 
  appropriate behavior when Audit is invoked on a package, but not when invoked
  on a component.  
5.3  The second issue manifests itself as inconsistent and sometimes incorrect
  reporting of the results of the audit in the report dialog.  This is shown in
  the video attached to [2].  Here is a textual capture of the failures from the
  video:  
  - set up jar file for realized component
  - audit
  - __R__ success
  - change path to jar to be wrong
  - audit
  - __R__ ERROR: incorrectly reports success
  - change path to jar again, still to be wrong
  - audit
  - __R__ ERROR: no result dialog is displayed
  - Change path to jar to be right
  - audit
  - __R__ ERROR: no result dialog is displayed
  - audit
  - __R__ Success: audit reports correct

6. Design
---------
6.1  The fix for 5.2 will be in VerifierInvocationAuditor.java::internalPerformRealizedCodeAudit(). 
  Change:  
  
```java
        Component_c[] components = null;
        try {
            components = collectElements(elem,
                    Elementtypeconstants_c.COMPONENT, null);
            clearBindings(components);
```  

to  

```java
        Set<NonRootModelElement> components = null;
        try {
            components = collectElements(elem,
                    Elementtypeconstants_c.COMPONENT, null);
            if (elem instanceof Component_c) {
                components.add(elem);
            }
            clearBindings(components.toArray(new Component_c[0]));
```  

  This change makes sure that if the audit was invoked on a component, that 
  component is added to this list of elements that are collected for later 
  audit checks.  Since Java provides no facility to simply add to an array, I've
  chosen to just use the raw set that is returned from ``` collectElements() ```
  and cast it to a component array only when necessary.    
  
6.2  The issue shown in 5.3 is more complicated.  In class 
  VerifierInvocationAuditor::internalPerformRealizedAudit() we find this code
  currently:

```java
    components = collectElements(elem,
        Elementtypeconstants_c.COMPONENT, null).toArray(
            new Component_c[0]);
    clearBindings(components);                      
    for (Component_c component : components) {
        result += performAudit(component);
    }
```

  The class VerifierInvocationAuditor has a class member:

```java
private static Map<NonRootModelElement, BPClassLoader> classLoaderMap = new HashMap<NonRootModelElement, BPClassLoader>();
```

  The ```collectElements()``` call shown above recursively drills down 
  collecting components, interfaces and datatypes.  As it goes, it locates (or 
  creates if necessary) instances of BPClassLoader in Vm_c for SystemModel_c 
  instances that contain the element being processed.  

  This is all well and good, except that as soon as ```collectElements()``` is 
  done, the code calls ```clearBindings()``` which removes class loaders from 
  the map of class loaders in Vm_c and then creates a new one in the Vm_c for
  the system currently being processed.  

  So, we have two different maps of class loaders, one in 
  VerifierInvocationAuditor and one in Vm_c.  Because of the creation, then 
  clearing, then re-creation of the system classloaders as described above, 
  the map of classloaders in VerifierInvocationAuditor ends up getting out of
  synch with the map of current system classloaders in Vm_c.  

6.2.1  The solution to this problem is to just get rid of the local map of 
  classloaders in VerifierInvocationAuditor.  This simplifies the 
  ```collectElements()``` call because it no longer needs to populate the local
  map.  This solution also means that we no longer keep two maps of the same
  data, thus we don't have to worry about stale data in either copy.  Instead, 
  we just have one map of classloaders and modify the VerifierInvocationAuditor 
  to get the classloader to use from Vm_c instead of from its local map.    

6.2.2  The map of classloaders in VerifierInvocationAuditor is currently a 
  private class member variable.  There are no public accessor functions that 
  get or set data in the classloader map.  Hence, there are no other entities 
  outside this class that rely on the data in its current form.  

7. Design Comments
------------------
7.1  While doing the analysis for this issue, the author found a number of TODOs
  in ```bp.debug.ui/.../BPDebugTarget.java::setupForRealizedExecution()```. 
  The TODOs are mostly to add error handling for various scenarios.  These shall
  be resolved with this issue.

8. Unit Test
------------
8.1  Both of the verifier JUnit test suites must pass.  
  
8.2  Manual test must pass:  
  - set up jar file for realized component
  - invoke audit on the parent package of the component
  - __R__ successfully report valid binding
  - change path to jar to be wrong
  - invoke audit on the parent package of the component
  - __R__ successfully report invalid binding
  - change path to jar again, still to be wrong
  - invoke audit on the parent package of the component
  - __R__ successfully report invalid binding
  - Change path to jar to be right
  - invoke audit on the parent package of the component
  - __R__ successfully report valid binding
  - invoke audit on the parent package of the component
  - __R__ successfully report valid binding
  
  - invoke audit on the realized component itself
  - __R__ successfully report valid binding
  - change path to jar to be wrong
  - invoke audit on the realized component itself
  - __R__ successfully report invalid binding
  - change path to jar again, still to be wrong
  - invoke audit on the realized component itself
  - __R__ successfully report invalid binding
  - Change path to jar to be right
  - invoke audit on the realized component itself
  - __R__ successfully report valid binding
  - invoke audit on the realized component itself
  - __R__ successfully report valid binding
    
End
---

