#!/usr/bin/perl -w
#
# (C) Tony Garnock-Jones, 2000.
# Released under the Perl "Artistic" License:
# http://www.perl.com/language/misc/Artistic.html
#
# $Id: logmsg.verify,v 1.1 2007/02/02 20:38:59 tlondon Exp $
#
# Usage:
#   logmsg.verify <log-message-filename>
#
# Checks the log file given in <log-message-filename> to make sure it
# fits certain constraints:
#
# 1. the job ID entered must -
#    1. either exist in the table general_jobs (see readGeneralJobs)
#    2. or be a valid, open bugzilla bug number
#
# 2. the change description must be non-empty.

use Mysql;

use diagnostics;
use strict;

use vars qw($db $jobid_re $nonlogged_branches);

my $scriptdir = `dirname $0`;
chomp $scriptdir;
require "$scriptdir/logmsg-parsing.pl";

###########################################################################
# Subroutines

# Check the Bugzilla database for the presence of an open, numbered bug.
sub isBugValid($) {
    my ($bugnumber) = @_;

    my $query = $::db->query("select count(*) from bugs.bugs where " .
			     "bug_id=$bugnumber and " .
			     "bug_status in ('NEW', 'ASSIGNED', 'REOPENED', 'MOREINFO')");
    my @result = $query->fetchrow();

    return ($result[0] == 1);
}

# If the passed-in bug number is not committable-against, die with an
# error message.
sub validateBugNumber($) {
    my ($bugnumber) = @_;

    if (!isBugValid($bugnumber)) {
	diePrinting("Bug number $bugnumber either does not exist, or is\n" .
		    "RESOLVED, VERIFIED or CLOSED.");
    }
}

# Make sure we can commit against a job ID.
sub validateJob($) {
    my ($jobid) = @_;

    if (!isGeneralJob($jobid)) {
	# First check that it really is a number.
	$jobid =~ /^\d+$/
	    || diePrinting("Bug numbers must consist of a sequence of digits only.\n" .
			   "Therefore, job ID \"$jobid\" is not a bug number.\n" .
			   "(Could it be a misspelt \"general job\" name?)");

	# Now check it's entry in the DB.
	validateBugNumber($jobid);
    }
}

###########################################################################
# Main routine of script

sub main() {
    # We require exactly one argument.
    (scalar(@ARGV) == 1) || diePrinting("Script logmsg.verify invoked wrongly.");

    # Read our log message input file.
    open(LOGMSG, $ARGV[0]) || diePrinting("Log message not readable by script. That's strange.");
    my @line = readline(*LOGMSG);		# read all the lines in the file
    close(LOGMSG);

    # the first line is the "Job ID:" line
    my $jobids_line = shift @line;
    my @jobstring = split(/ /, $jobids_line);
    my $jobstring = shift @jobstring;

    if ($jobstring eq "Initial") {

    	$jobids_line = "Job: project_creation";
	@line = "Initial Project Creation";
	}

	my $i;

	foreach $i (@::nonlogged_branches){

	if (open (TAG, "./CVS/Tag")) {

	my @branch = <TAG>;
	my $branch = shift @branch;
	$branch =~ s/^T//g;

	close(TAG);

	if($branch =~ /$i/i . "\n") {
		print "Passed verification, branch is in nonlogged_branches list\n";
		exit();
		}
	}
}

    my ($status, @jobids) = splitJobLine($jobids_line);
    if (!$status) {
	diePrinting("Log message must include first line starting with one of:\n\t" .
		    join(" <jobID>\n\t", @::jobid_re) . " <jobID>");
    }

    # Ensure there's at least one.
    (scalar(@jobids) > 0) || diePrinting("At least one Job ID must be listed in the log message.");

    # Check them all out.
    foreach my $jobid (@jobids) {
	$jobid || next;
	validateJob($jobid);
    }

    # Make sure there's a description of some sort.
    (scalar(@line) > 0)
	|| diePrinting("The log message must contain a description of the change.\n" .
		       "Please try to make it meaningful (it will go into bugzilla).");

    # At this point, we know that everything's cool!
    exit(0);
}

###########################################################################
# Main body

main();
